pipeline {
    agent any

    environment {
        MODULE_NAMESPACE_1 = 'ingress-nginx'
        MODULE_NAMESPACE_2 = 'ticketing-app'
    }

    stages {
        stage('Install required tools on Agent Node') {
            steps {
                withCredentials([string(credentialsId: 'wsl-agent-sudo-password', variable: 'SUDO_PASSWORD')]) {
                    sh '''
                        ## Switch to Root user
                        echo "${SUDO_PASSWORD}" | sudo -SE su root
                        whoami
                        
                        ## Install basic utilities
                        sudo apt-get update
                        sudo apt-get install -y curl jq
                        
                        ## Install Skaffold...
                        if !(skaffold version)
                        then
                            echo "Installing Skaffold"
                            curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64
                            sudo install skaffold /usr/local/bin/
                        else
                            echo "Skaffold is already installed"
                        fi
                        
                        ## Install Docker...
                        docker_version_output=$(docker -v 2>&1)
                        if [ $? -eq 0 ]
                        then
                            echo "Docker is already installed"
                        else
                            echo "Installing Docker"
                            # Remove any previously installed unofficial Docker packages
                            for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do 
                              sudo apt-get remove $pkg 
                            done
                            
                            # Add Docker official GPG key
                            sudo apt-get update
                            sudo apt-get install ca-certificates curl gnupg
                            sudo install -m 0755 -d /etc/apt/keyrings
                            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
                            sudo chmod a+r /etc/apt/keyrings/docker.gpg
                            
                            # Add the repository to Apt sources
                            echo \
                              "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                              "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
                              sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                            sudo apt-get update
                            
                            # Install the latest version
                            sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
                            
                            # Test the installation
                            sudo docker run hello-world
                        fi
                        
                            
                        ## Install Kubectl...
                        kubectl_version_output=$(kubectl version --client 2>&1)
                        if [ $? -eq 0 ]
                        then
                            echo "Kubectl is already installed"
                        else
                            echo "Installing Kubectl"
                            # Update the apt package index and install packages needed to use the Kubernetes apt repository
                            sudo apt-get update
                            sudo apt-get install -y apt-transport-https ca-certificates
                            
                            # Download the public signing key for the Kubernetes package repositories
                            curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
                            
                            # Add the appropriate Kubernetes apt repository. This overwrites any existing configuration in /etc/apt/sources.list.d/kubernetes.list
                            echo \
                            "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /" | \
                            sudo tee /etc/apt/sources.list.d/kubernetes.list > /dev/null
                            
                            # Finally install kubectl
                            sudo apt-get update
                            sudo apt-get install -y kubectl
                            
                            # Test to ensure the version installed is as mentioned
                            kubectl version --client
                            
                            # Verify kubectl configuration by acesing a K8 cluster. Note:- For kubectl to do that, it needs a kubeconfig file located at ~/.kube/config
                            kubectl cluster-info
                        fi
                        
                        ## Switch back to default user
                        exit
                    '''
                }                
            }
        }
        
        stage('Checkout Git Repo') {
            steps {
                // Clone the Git Repo in the Agent
                checkout scmGit(branches: [[name: '*/main']], extensions: [submodule(recursiveSubmodules: true, reference: '')], userRemoteConfigs: [[url: 'https://github.com/arnab-bhowmik/Ticketing-App.git']])
            }
        }
        
        stage('Install NPM Dependencies') {
            steps {
                dir("${env.WORKSPACE}/auth-service"){
                    echo "Current Directory is:"
                    sh "pwd"
                    sh 'npm install'
                }
                dir("${env.WORKSPACE}/client"){
                    echo "Current Directory is:"
                    sh "pwd"
                    sh 'npm install'
                }
                dir("${env.WORKSPACE}/Custom-Modules"){
                    echo "Current Directory is:"
                    sh "pwd"
                    sh 'npm install'
                }
            }
        }
        
        stage('Deploy Application on Kubernetes Cluster') {
            steps {
                withCredentials([string(credentialsId: 'jwt-secret-key', variable: 'JWT_KEY')]) {
                    withEnv(["MODULE_NS_1=${env.MODULE_NAMESPACE_1}", "MODULE_NS_2=${env.MODULE_NAMESPACE_2}"]) {
                        dir("${env.WORKSPACE}"){
                            echo "Current Directory is:"
                            sh "pwd"
                            
                            sh '''
                                MODULE_NAMESPACE_1="${MODULE_NS_1}"
                                MODULE_NAMESPACE_2="${MODULE_NS_2}"
                                
                                # Deploy the ingress-nginx controller on Kubernetes cluster via Skaffold
                                skaffold deploy --module ${MODULE_NAMESPACE_1}
                                
                                echo "Displaying the Kubernetes Deployments, Pods & Services for namespace - ${MODULE_NAMESPACE_1}"
                                kubectl get deployment  -n ${MODULE_NAMESPACE_1}
                                kubectl get pods        -n ${MODULE_NAMESPACE_1}
                                kubectl get services    -n ${MODULE_NAMESPACE_1}
                                
                                
                                # Create the namespace
                                kubectl create namespace ${MODULE_NAMESPACE_2}
                                
                                # Create a JWT Secret to be used for Authentication
                                kubectl create secret generic jwt-secret -n ${MODULE_NAMESPACE_2} --from-literal=JWT_KEY="${JWT_KEY}"
                                
                                # Build the Application Docker Images via Skaffold
                                skaffold build --module ${MODULE_NAMESPACE_2} --file-output=build_artifacts.json
                                
                                # Deploy the built artifacts on Kubernetes cluster via Skaffold
                                skaffold deploy --module ${MODULE_NAMESPACE_2} --build-artifacts=build_artifacts.json
                                
                                echo "Displaying the Kubernetes Deployments, Pods & Services for namespace - ${MODULE_NAMESPACE_2}"
                                kubectl get deployment  -n ${MODULE_NAMESPACE_2}
                                kubectl get pods        -n ${MODULE_NAMESPACE_2}
                                kubectl get services    -n ${MODULE_NAMESPACE_2}
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Test APIs for User SignUp/SignIn/SignOut & Authentication') {
            steps {
                dir("${env.WORKSPACE}/auth-service"){
                    echo "Current Directory is:"
                    sh "pwd"
                    sh 'npm test'
                }
            }
        }
        
        stage('Push Images to Docker Hub') {
            environment {
                DOCKER_IMAGE_NAMES = ' ' 
            }
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-creds', usernameVariable: 'DOCKER_HUB_USERNAME', passwordVariable: 'DOCKER_HUB_PASSWORD')]) {
                        withEnv(["DOCKER_IMAGE_NAMES=${DOCKER_IMAGE_NAMES}"]) {
                            sh '''
                                docker login -u $DOCKER_HUB_USERNAME -p $DOCKER_HUB_PASSWORD
                                # Build and store the Docker Image details in JSON format
                                skaffold build -q --dry-run > skaffold_build_result.json
                                
                                for item in $(cat skaffold_build_result.json | jq -c '.builds[]'); do
                                    # Extract the image name and corresponding tag
                                    echo "Extracting the image name and corresponding tag..."
                                    imageName=$(echo "$item" | jq -r '.imageName')
                                    tag=$(echo "$item" | jq -r '.tag | split(":")[1]')
                                    
                                    # Tag the extracted Docker image before pushing to Docker Hub
                                    echo "Tagging the extracted Docker image before pushing to Docker Hub"
                                    docker tag $imageName:$tag $DOCKER_HUB_USERNAME/$imageName:latest
                                
                                    # Push the image to Docker Hub
                                    echo "Pushing the image to Docker Hub"
                                    docker push $DOCKER_HUB_USERNAME/$imageName:latest
                                
                                    # Print the results & delete the :latest tagged image
                                    echo "Pushed image $imageName with tag $tag to Docker Hub with tag as latest"
                                    docker rmi $DOCKER_HUB_USERNAME/$imageName:latest
                                    
                                    # Save the image name as environment variable to access later for cleanup
                                    updatedArray="${DOCKER_IMAGE_NAMES},${imageName}"
                                    DOCKER_IMAGE_NAMES=$(echo $updatedArray | sed 's/^[,[:space:]]*//;s/[,[:space:]]*$//')
                                    echo "Updated image name list: ${DOCKER_IMAGE_NAMES}"  
                                done
                                
                                # Store the environment variable in a file to pass it to the next stage
                                echo "${DOCKER_IMAGE_NAMES}" > docker_image_names.txt
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Cleanup Agent Node') {
            steps {
                script {
                    withEnv(["MODULE_NS_1=${env.MODULE_NAMESPACE_1}", "MODULE_NS_2=${env.MODULE_NAMESPACE_2}"]) {
                        sh '''
                            MODULE_NAMESPACE_1="${MODULE_NS_1}"
                            MODULE_NAMESPACE_2="${MODULE_NS_2}"
                        
                            # Delete the JWT secret
                            kubectl delete secret jwt-secret -n ${MODULE_NAMESPACE_2}
                            
                            # Stop skaffold 
                            echo "Stopping skaffold to clean up the deployed applications & services for all kubernetes namespaces..."
                            skaffold delete --module ${MODULE_NAMESPACE_1}
                            skaffold delete --module ${MODULE_NAMESPACE_2}
                            sleep 30
                        '''
                        
                        // Access the environment variable from the previous stage
                        DOCKER_IMAGE_NAMES = readFile('docker_image_names.txt').trim()
                        
                        // Delete locally built Docker Images iterating on the names
                        DOCKER_IMAGE_NAMES.tokenize(",").each { name ->
                            sh """
                                # Delete skaffold generated Docker images on the Agent Node
                                echo "Deleting skaffold generated Docker image $name on the Agent Node"
                                docker images --format "{{.Repository}}:{{.Tag}}" | grep "^$name:" | xargs -I {} docker rmi {}
                            """
                        }
                        
                        sh '''
                            # Get the list of container IDs for created & exited containers
                            created_container_ids=$(docker ps -aq -f status=created)
                            exited_container_ids=$(docker ps -aq -f status=exited)
                            
                            # Remove created containers if the list is not empty 
                            if [ -n "$created_container_ids" ]; then
                                # Remove created containers
                                docker rm -f $created_container_ids
                                echo "Created containers removed"
                            else
                                echo "No created containers found"
                            fi
                            
                            # Remove exited containers if the list is not empty
                            if [ -n "$exited_container_ids" ]; then
                                # Remove exited containers
                                docker rm -f $exited_container_ids
                                echo "Exited containers removed"
                            else
                                echo "No exited containers found"
                            fi
                            
                            # Remove any dangling images thereafter
                            echo "Removing any dangling images"
                            docker image prune -f
                        '''
                    }
                }
            }
        }
    }
}